<html>
<head>
	<title>SVG test 2</title>
</head>
<body style="overflow: hidden;background-color:rgb(0,0,0)">
	<div style="position:relative;border:1px solid #000000;width:100%;height:100%;background-color:#000000;border:1pt solid #999999" id="viewPort"></div>
	<!-- <div style="position:relative;border:1px solid #000000;width:100%;height:50%;background-color:#000000;border:1pt solid #999999" id="viewPort2"></div> -->

<script language="JavaScript">
var SvgScene=function(){
	var Color=function(r_, g_, b_){
		var r=r_;
		var g=g_;
		var b=b_;
		return {
			toString: function(){return "rgb("+r+", "+g+", "+b+")";},
			toString2: function(){return r+","+g+","+b;}
		};
	}

	var threeD=(function(){
		var Point=function(x_, y_, z_){
			var x=x_;
			var y=y_;
			var z=z_;
			var p={
				x: function(){return x;},
				y: function(){return y;},
				z: function(){return z;},
				plus: function(p){return Point(p.x()+x, p.y()+y,p.z()+z);},
				scale: function(r){return Point(r*x,r*y,r*z);},
				minus: function(p){return Point(x-p.x(), y-p.y(),z-p.z());},
				dot: function(p){return x*p.x()+y*p.y()+z*p.z();},
				cross: function(p){return Point(y*p.z()-z*p.y(),z*p.x()-x*p.z(),x*p.y()-y*p.x());},
				norm: function(){return Math.sqrt(x*x+y*y+z*z);},
				unit: function(){if(this.norm()==0){return this;}else{return this.scale(1/this.norm());}},
				project: function(p){
					var u=this.unit();
					return u.scale(u.dot(p));
				},
				projectOnPlane: function(p,n){
					var tmp=this.minus(p);
					return p.plus(tmp.minus(n.project(tmp)));
				},
				rotate: function(around, axis, angle){
					var op=this.minus(around);
					if(axis==0){
						var npy=op.y()*Math.cos(angle)-op.z()*Math.sin(angle);
						var npz=op.z()*Math.cos(angle)+op.y()*Math.sin(angle);
						return around.plus(Point(op.x(), npy, npz));
					}
					if(axis==1){
						var npz=op.z()*Math.cos(angle)-op.x()*Math.sin(angle);
						var npx=op.x()*Math.cos(angle)+op.z()*Math.sin(angle);
						return around.plus(Point(npx, op.y(), npz));
					}
					if(axis==2){
						var npx=op.x()*Math.cos(angle)-op.y()*Math.sin(angle);
						var npy=op.y()*Math.cos(angle)+op.x()*Math.sin(angle);
						return around.plus(Point(npx, npy, op.z()));
					}
				},
				rotateWithRotation: function(r){
					return this.rotate(r.around, r.axis, r.angle);
				},
				rotateWithOtherRotation: function(r){
					var op=this.minus(r.around);
					var opUnchanged=r.direction.project(op);
					op=op.minus(opUnchanged);
					if(op.norm()>0){
						var yAxis=r.direction.cross(op);
						op=op.scale(Math.cos(r.angle)).plus(yAxis.unit().scale(op.norm()*Math.sin(r.angle)));
						return r.around.plus(opUnchanged).plus(op);
					}else{
						return Point(x, y, z);
					}
				},
				perpendicularTo: function(p){return Math.abs(this.dot(p))<0.0005;},
				isZero: function(){return x==0&&y==0&&z==0;},
				sameDirection: function(p){return !this.isZero()&&!p.isZero()&&(this.dot(p)==this.norm()*p.norm());},
			};
			return p;
		};
		var Line=function(point1, point2){
			var p1=point1;
			var baseVector=point2.minus(point1);
			var intersectWithPlane=function(point, normal){
				if(baseVector.perpendicularTo(normal)){return null;}
				var t=-normal.dot(p1.minus(point))/normal.dot(baseVector);
				return p1.plus(baseVector.scale(t));
			};
			var l={
				p1: function(){return p1;},
				baseVector: function(){return baseVector;},
				intersectWithPlane: intersectWithPlane
			};
			return l;
		};
		var Rotation=function(around, axis, angle){
			return {
				around: around,
				axis: axis,
				angle: angle
			};
		};
		var OtherRotation=function(around, axisDirection, angle){
			return {
				around: around,
				direction: axisDirection,
				angle: angle
			};
		};
		var or=Point(0,0,0);
		var xu=Point(1,0,0);
		var yu=Point(0,1,0);
		var zu=Point(0,0,1);
		return {
			Point: Point,
			Line: Line,
			Rotation: Rotation,
			OtherRotation: OtherRotation,
			or: or,
			xu: xu,
			yu: yu,
			zu: zu
		};
	})();
	var Point=threeD.Point;
	var Line=threeD.Line;
	var OtherRotation=threeD.OtherRotation;
	var Rotation=threeD.Rotation;
	var or=threeD.or;
	var xu=threeD.xu;
	var yu=threeD.yu;
	var zu=threeD.zu;

	var twoD=(function(){
		var w,h,corners,ltcorners;
		var d=function(lt1, lt2){return plt(lt1).minus(plt(lt2)).norm();};
		var p=function(x,y){return Point(x,y,0);};
		var plt=function(lt){return p(lt.left, lt.top);};
		var ltp=function(p){return {left:p.x(),top:p.y()};};
		var intersectLineSegments=function(p1,p2,p3,p4){
			var a=p2.minus(p1);
			var b=p4.minus(p3);
			var c=p3.minus(p1);
			var d=a.cross(b);
			var nd=d.norm();
			if(nd==0){return null;}
			var i=p1.plus(a.scale(c.cross(b).dot(d)/Math.pow(nd, 2)));
			return ltp(i);
		};
		var distanceToLine=function(p1, direction, p2){
			var l=p2.minus(p1);
			return l.norm()*l.unit().dot(direction.unit());
		};
		var distanceToEdge=function(lt1, lt2){
			var direction=plt(lt2).minus(plt(lt1));
			var d=0;
			for(var i=0;i<4;i++){
				var dd=distanceToLine(plt(lt2), direction, corners[i]);
				if(dd>=d){d=dd;}
			}
			return d;
		};
		var moveToEdge=function(lt1, lt2, w, h){
			var d_=d(lt1, lt2);
			var d1=distanceToEdge(lt1, lt2);
			return {left:lt1.left+(lt2.left-lt1.left)*(1+d1/d_),top:lt1.top+(lt2.top-lt1.top)*(1+d1/d_)};
		};
		var setCorners=function(){
			corners=[p(0,0), p(0,h), p(w, h), p(w,0)];
			ltcorners=[{left:0,top:0},{left:0,top:h},{left: w, top:h},{left:w,top:0}];
		};
		var makeInfinite=function(lt1, lt2, hlt){
			var d_=d(lt1, lt2);
			var nlt1=lt1;
			var nlt2=lt2;
			if(d_!=0){
				if(hlt!=null&&((hlt.left<lt1.left&&lt1.left<lt2.left)||(hlt.left>lt1.left&&lt1.left>lt2.left))){
					nlt1=hlt;
				}else{
					var toEdge=moveToEdge(lt2, lt1, w, h);
					nlt1=toEdge;
				}
				if(hlt!=null&&((hlt.left<lt2.left&&lt2.left<lt1.left)||(hlt.left>lt2.left&&lt2.left>lt1.left))){
					nlt2=hlt;
				}else{
					var toEdge=moveToEdge(lt1, lt2, w, h);
					nlt2=toEdge;
				}
			}
			return [nlt1, nlt2];
		};
		var completeTheSquare=function(lt1, lt2, lt3){
			var step1=plt(lt1);
			var step2=plt(lt2);
			var a=step2.minus(step1);
			var b=plt(lt3).minus(step1);
			if(a.cross(b).z()>0){
				var step3=step2.plus(Point(-a.y(), a.x(), 0));
			}else{
				var step3=step2.plus(Point(a.y(), -a.x(), 0));
			}
			var step4=step3.plus(a.scale(-1));
			return [ltp(step3),ltp(step4)];
		};
		return {
			setWh: function(w_,h_){w=w_;h=h_;setCorners();},
			ltcorners: function(){return ltcorners;},
			makeInfinite: makeInfinite,
			completeTheSquare: completeTheSquare
		};
	})();

	var viewPort=(function(){
		var w,h,normal;
		var leftTop=Point(1, 1, -1);
		var leftAxis=Point(-1,0,0);
		var topAxis=Point(0,-1,0);
		var viewPoint=Point(0,0,-3);
		var setSize=function(){
			var r=h/w;
			leftTop=Point(0.5, 0.5*r,-1);
			topAxis=topAxis.scale(r);
			normal=leftAxis.cross(topAxis);
		};
		var setScale=function(r){
			leftAxis=leftAxis.scale(r);
			topAxis=topAxis.scale(r);
		};
		var horizonLt=function(line){
			var direction=line.baseVector();
			if(direction.perpendicularTo(normal)){return null;}
			if(direction.dot(normal)<0){direction=direction.scale(-1);}
			return lt(viewPoint.plus(direction));
		};
		var getVisiblePointsOn=function(line){
			if(line.baseVector().perpendicularTo(normal)){
				if(line.p1().minus(viewPoint).dot(normal)>0){return [lt(line.p1()), lt(line.p1().plus(line.baseVector()))];}
				else{return [null, null];}
			}
			var p1=line.intersectWithPlane(leftTop, normal);
			var p2=p1.scale(0.5).plus(line.intersectWithPlane(viewPoint, normal).scale(0.5));
			return [lt(p1),lt(p2)];
		};
		var getVisiblePointsBetween=function(p1, p2){
			var ltp1=lt(p1);
			var ltp2=lt(p2);
			if(ltp1==null&&ltp2==null){return [null, null];}
			if(ltp1!=null&&ltp2!=null){return [ltp1, ltp2];}
			var p3=Line(p1,p2).intersectWithPlane(viewPoint, normal);
			if(ltp1==null){
				return [lt(p2.plus(p3).scale(0.5)), ltp2];
			}
			if(ltp2==null){
				return [ltp1, lt(p1.plus(p3).scale(0.5))];
			}
		};
		var lt=function(point){
			var line=Line(viewPoint, point);
			if(line.baseVector().perpendicularTo(normal)){return null;}
			var t=-normal.dot(viewPoint.minus(leftTop))/normal.dot(line.baseVector());
			if(t<0){return null;}
			var inPlane=viewPoint.plus(line.baseVector().scale(t));
			var leftTopToInPlane=inPlane.minus(leftTop);
			var l=leftAxis.unit().dot(leftTopToInPlane)/leftAxis.norm();
			var t=topAxis.unit().dot(leftTopToInPlane)/topAxis.norm();
			return {left: l*w,top: t*h};
		};
		var rotateWithOtherRotation=function(r){
			leftAxis=leftTop.plus(leftAxis);
			topAxis=leftTop.plus(topAxis);
			leftTop=leftTop.rotateWithOtherRotation(r);
			leftAxis=leftAxis.rotateWithOtherRotation(r).minus(leftTop);
			topAxis=topAxis.rotateWithOtherRotation(r).minus(leftTop);
			viewPoint=viewPoint.rotateWithOtherRotation(r);
			normal=leftAxis.cross(topAxis);
		};
		var rotX=function(angle){
			rotateWithOtherRotation(OtherRotation(or, leftAxis, angle));
		};
		var rotY=function(angle){
			rotateWithOtherRotation(OtherRotation(or, topAxis, angle));
		};
		var rotZ=function(angle){
			rotateWithOtherRotation(OtherRotation(or, leftAxis.cross(topAxis), angle));
		};
		var scale=function(r){
			leftTop=leftTop.scale(r);
			leftAxis=leftAxis.scale(r);
			topAxis=topAxis.scale(r);
			viewPoint=viewPoint.scale(r);
			normal=leftAxis.cross(topAxis);
		};
		var toString=function(){
			var s='<viewport w="'+w+'" h="'+h+'">';
			s+='<lefttop x="'+leftTop.x()+'" y="'+leftTop.y()+'" z="'+leftTop.z()+'" />';
			s+='<leftaxis x="'+leftAxis.x()+'" y="'+leftAxis.y()+'" z="'+leftAxis.z()+'" />';
			s+='<topaxis x="'+topAxis.x()+'" y="'+topAxis.y()+'" z="'+topAxis.z()+'" />';
			s+='<viewpoint x="'+viewPoint.x()+'" y="'+viewPoint.y()+'" z="'+viewPoint.z()+'" />';
			s+='</viewport>';
			return s;
		};
		return {
			lt: lt,
			setWh: function(w_, h_){w=w_; h=h_; setSize();},
			leftTop: function(){return leftTop;},
			leftAxis: function(){return leftAxis;},
			topAxis: function(){return topAxis},
			normal: function(){return normal;},
			viewPoint: function(){return viewPoint;},
			rotX: rotX,
			rotY: rotY,
			rotZ: rotZ,
			getVisiblePointsBetween: getVisiblePointsBetween,
			getVisiblePointsOn: getVisiblePointsOn,
			toString: toString,
			scale: scale,
			horizonLt: horizonLt
		};
	})();
	
	var LineSegmentFactory=(function(){
		var lineSegments=[];
		var currentNumber=0;
		var LineSegment=function(from_, to_){
			var from, to, thisSvg;
			var setFromTo=function(from_, to_){
				from=from_;
				to=to_;
			};
			var draw=function(){
				var visible=viewPort.getVisiblePointsBetween(from, to);
				var flt=visible[0];
				var tlt=visible[1];
				if(flt==null||tlt==null){
					thisSvg.none();
				}else{
					thisSvg.setFromTo(flt, tlt);
					thisSvg.draw();
				}
			};
			var setColor=function(color){
				thisSvg.setColor(color);
			};
			var setSvg=function(svg_){
				thisSvg=svg_;
			};
			setFromTo(from_, to_);
			return {
				setFromTo: setFromTo,
				draw: draw,
				setColor: setColor,
				setSvg: function(svg_){setSvg(svg_); return this;}
			};
		};
		var makeLineSegment=function(from, to, color){
			var id="lineSegment"+currentNumber;
			var index=currentNumber;
			var svgThing=svg.addLineSegment(0,0,0,0, id, index, color);
			var ls=LineSegment(from, to).setSvg(svgThing);
			lineSegments[currentNumber]=ls;
			currentNumber++;
			return ls;
		};
		return {
			makeLineSegment: makeLineSegment,
			lineSegments: function(){return lineSegments;}
		};
	})();

	var LineLineFactory=(function(){
		var lineLines=[];
		var currentNumber=0;
		var LineLine=function(p1_, p2_){
			var p1,p2,line,thisSvg;
			var setFromTo=function(p1_,p2_){
				p1=p1_;
				p2=p2_;
				line=Line(p1_,p2_);
			};
			var draw=function(){
				var visible=viewPort.getVisiblePointsOn(line);
				var p1lt=viewPort.lt(p1);
				if(p1lt==null){p1lt=visible[0];}
				var p2lt=viewPort.lt(p2);
				if(p2lt==null){p2lt=visible[1];}
				var hlt=viewPort.horizonLt(line);
				if(p1lt==null&&p2lt==null){
					thisSvg.none();
				}else{
					thisSvg.setFromTo(p1lt, p2lt);
					thisSvg.makeInfinite(hlt);
				}
				thisSvg.draw();
			};
			var setColor=function(color){
				thisSvg.setColor(color);
			};
			var setSvg=function(svg_){
				thisSvg=svg_;
			};
			setFromTo(p1_,p2_);
			return {
				setFromTo: setFromTo,
				draw: draw,
				setColor: setColor,
				setSvg: function(svg_){setSvg(svg_); return this;}
			};
		};
		var makeLineLine=function(p1, p2, color, thickness){
			var id="lineLine"+currentNumber;
			var index=currentNumber;
			var svgThing=svg.addLineLine(0,0,0,0, id, index, color, thickness);
			var ll=LineLine(p1, p2).setSvg(svgThing);
			lineLines[currentNumber]=ll;
			currentNumber++;
			return ll;
		};
		return {
			makeLineLine: makeLineLine,
			lineLines: function(){return lineLines;}
		};
	})();

	var PlaneFactory=(function(){
		var planes=[];
		var currentNumber=0;
		var Plane=function(point_, normal_, color_){
			var point, normal, color, thisSvg, gridLines, xAxis, yAxis;
			point=point_;
			normal=normal_;
			color=color_;
			var setAxes=function(){
				if(normal.cross(xu).norm()!=0){
					xAxis=point.plus(xu).projectOnPlane(point, normal).minus(point).unit();
				}
				else if(normal.cross(yu).norm()!=0){
					xAxis=point.plus(yu).projectOnPlane(point, normal).minus(point).unit();
				}
				else if(normal.cross(zu).norm()!=0){
					xAxis=point.plus(zu).projectOnPlane(point, normal).minus(point).unit();
				}
				yAxis=normal.cross(xAxis);
			};
			var getHorizonLts=function(){
				var horizonDirections=[];
				horizonDirections[0]=normal.cross(viewPort.leftAxis());
				horizonDirections[1]=normal.cross(horizonDirections[0]);
				horizonDirections[2]=horizonDirections[0].plus(horizonDirections[1]);
				horizonDirections[3]=normal.cross(viewPort.topAxis());
				horizonDirections[4]=normal.cross(horizonDirections[3]);
				horizonDirections[5]=horizonDirections[3].plus(horizonDirections[4]);
				var nonNullHlt=[];
				var count=0;
				for(var i=0;i<horizonDirections.length;i++){
					var hlt=viewPort.horizonLt(Line(point, point.plus(horizonDirections[i])));
					if(hlt!=null){
						nonNullHlt[count++]=hlt;
					}
					if(count==2){break;}
				}
				return nonNullHlt;
			};
			var getInPlaneLt=function(){
				var lt_;
				var inPlane1=Line(viewPort.leftTop(), viewPort.leftTop().plus(viewPort.leftAxis())).intersectWithPlane(point, normal);
				var inPlane2=Line(viewPort.leftTop(), viewPort.leftTop().plus(viewPort.topAxis())).intersectWithPlane(point, normal);
				if(inPlane1==null){
					lt_=viewPort.lt(inPlane2);
				}else{
					lt_=viewPort.lt(inPlane1);
				}
				return lt_;
			};
			var pointWithCoords=function(x,y){
				return point.plus(xAxis.scale(x)).plus(yAxis.scale(y));
			};
			var getPairwiseGridPoints=function(){
				var gp=[];
				var n=20;
				for(var i=-n;i<=n;i++){
					gp.push([pointWithCoords(i,n), pointWithCoords(i,-n)]);
					gp.push([pointWithCoords(-n,i), pointWithCoords(n,i)]);
				}
				return gp;
			};
			var draw=function(){
				if(normal.cross(viewPort.normal()).norm()==0){
					if(point.minus(viewPort.viewPoint()).dot(viewPort.normal())>=0){thisSvg.full();}else{thisSvg.none();}
					thisSvg.draw();
					return;
				}
				var nonNullHlt=getHorizonLts();
				thisSvg.setHorizonPoints(nonNullHlt[0], nonNullHlt[1], getInPlaneLt());
				thisSvg.draw();
			};
			var setColor=function(color_){
				color=color_;
				thisSvg.setColor(color_);
				for(var i in gridLines){gridLines[i].setColor(color_);}
			};
			var toString=function(){
				return '<plane reflection="0" diffusion="0.4" color="'+color.toString2()+'">'+
				'<point x="'+point.x()+'" y="'+point.y()+'" z="'+point.z()+'"/>'+
				'<normal x="'+normal.x()+'" y="'+normal.y()+'" z="'+normal.z()+'"/>'+
				'</plane>';
			};
			var setSvg=function(svg_){
				thisSvg=svg_;
			};
			var setGrid=function(){
				var pairwiseGridPoints=getPairwiseGridPoints();
				for(var i in pairwiseGridPoints){
					gridLines[i].setFromTo(pairwiseGridPoints[i][0],pairwiseGridPoints[i][1]);
				}
			};
			var makeGrid=function(){
				gridLines=[];
				var pairwiseGridPoints=getPairwiseGridPoints();
				for(var i in pairwiseGridPoints){
					gridLines.push(LineLineFactory.makeLineLine(pairwiseGridPoints[i][0],pairwiseGridPoints[i][1], color, 1));
				}
			};
			setAxes();
			makeGrid();
			return {
				draw: draw,
				setColor: setColor,
				setSvg: function(svg_){setSvg(svg_);return this;},
				toString: toString
			};
		};
		var makePlane=function(point, normal, color){
			var id="plane"+currentNumber;
			var index=currentNumber;
			var svgThing=svg.addPlane(0,0,0,0,0,0,0,0,id,index, color);
			var p=Plane(point, normal, color).setSvg(svgThing);
			planes[currentNumber]=p;
			currentNumber++;
			return p;
		};
		return {
			makePlane: makePlane,
			planes: function(){return planes;}
		};
	})();

	var SphereFactory=(function(){
		var spheres=[];
		var lightSources=[];
		var currentNumber=0;
		var Sphere=function(center_, radius_, color_, toBecomeLightSource){
			var center, radius, color, gridLineSegments, thisSvg;
			center=center_;
			radius=radius_;
			color=color_;
			var draw=function(){
				var toCenter=center.minus(viewPort.viewPoint());
				var d=toCenter.norm();
				var r=radius;
				if(d<=r){thisSvg.none();thisSvg.draw();return;}
				var startingPoint=center.plus(toCenter.cross(viewPort.leftAxis()).unit().scale(d*r/Math.sqrt(d*d-r*r)));
				var pointList=[startingPoint];
				var n=24;
				var rot=OtherRotation(viewPort.viewPoint(), toCenter, 2*Math.PI/n);
				for(var i=1;i<n;i++){
					startingPoint=startingPoint.rotateWithOtherRotation(rot);
					pointList[pointList.length]=startingPoint;
				}
				var ltList=[];
				for(var i=0;i<pointList.length;i++){
					var lt=viewPort.lt(pointList[i]);
					if(lt!=null){ltList[ltList.length]=lt;}
				}
				thisSvg.setPoints(ltList);
				thisSvg.draw();
			};
			var setColor=function(color_){
				color=color_;
				thisSvg.setColor(color);
				for(var i in gridLineSegments){gridLineSegments[i].setColor(color_);}
			};
			var pointWithCoords=function(lo, la){
				return center.plus(xu.rotate(or, 2, la).rotate(or, 1, lo).scale(radius));
			};
			var getPairwiseGridPoints=function(){
				var gp=[];
				for(var lo=-Math.PI;lo<=Math.PI;lo+=Math.PI/8){
					var pointsOnMeridian_=pointsOnMeridian(lo,20);
					for(var i=1;i<pointsOnMeridian_.length;i++){
						gp.push([pointsOnMeridian_[i-1], pointsOnMeridian_[i]]);
					}
				}
				for(var la=-Math.PI/2;la<=Math.PI/2;la+=Math.PI/8){
					var pointsOnLatitude_=pointsOnLatitude(la, 20);
					for(var i=1;i<pointsOnLatitude_.length;i++){
						gp.push([pointsOnLatitude_[i-1], pointsOnLatitude_[i]]);
					}
				}
				return gp;
			};
			var pointsOnMeridian=function(lo, n){
				var pointsOnMeridian_=[];
				for(var la=-Math.PI/2; la<=Math.PI/2; la+=Math.PI/n){
					pointsOnMeridian_[pointsOnMeridian_.length]=pointWithCoords(lo,la);
				}
				return pointsOnMeridian_;
			};
			var pointsOnLatitude=function(la, n){
				var pointsOnLatitude_=[];
				for(var lo=-Math.PI;lo<=Math.PI;lo+=2*Math.PI/n){
					pointsOnLatitude_[pointsOnLatitude_.length]=pointWithCoords(lo,la);
				}
				return pointsOnLatitude_;
			};
			var setSvg=function(svg_){thisSvg=svg_;};
			var toString=(function(){
				if(!toBecomeLightSource){
					return function(){
						var s='<sphere reflection="0" diffusion="0.4" color="'+color.toString2()+'" radius="'+radius+'">'+
						'<center x="'+center.x()+'" y="'+center.y()+'" z="'+center.z()+'" />'+
						'</sphere>';
						return s;
					};
				}else{
					return function(){
						var s='<lightsource color="'+color.toString2()+'" radius="'+radius+'">'+
						'<location x="'+center.x()+'" y="'+center.y()+'" z="'+center.z()+'" />'+
						'</lightsource>';
						return s;
					};
				}
			})();
			/*var toString=function(){
				var s='<sphere reflection="0" diffusion="0.4" color="'+color.toString2()+'" radius="'+radius+'">'+
				'<center x="'+center.x()+'" y="'+center.y()+'" z="'+center.z()+'" />'+
				'</sphere>';
				return s;
			};*/
			var setGrid=function(){
				var pairwiseGridPoints=getPairwiseGridPoints();
				for(var i in pairwiseGridPoints){
					gridLineSegments[i].setFromTo(pairwiseGridPoints[i][0],pairwiseGridPoints[i][1]);
				}
			};
			var makeGrid=function(){
				gridLineSegments=[];
				var pairwiseGridPoints=getPairwiseGridPoints();
				for(var i in pairwiseGridPoints){
					gridLineSegments.push(LineSegmentFactory.makeLineSegment(pairwiseGridPoints[i][0],pairwiseGridPoints[i][1], color));
				}
			};
			makeGrid();
			return {
				draw: draw,
				setColor: setColor,
				setSvg: function(svg_){setSvg(svg_);return this;},
				toString: toString
			};
		};
		var makeSphere=function(center, radius, color){
			var id="sphere"+currentNumber;
			var index=currentNumber;
			var svgThing=svg.addSphere(color);
			var s=Sphere(center, radius, color, false).setSvg(svgThing);
			console.log(s.toString());
			spheres[currentNumber]=s;
			currentNumber++;
			return s;
		};
		var makeLightSource=function(center, radius, color){
			var svgThing=svg.addSphere(color);
			var s=Sphere(center, radius, color, true).setSvg(svgThing);
			lightSources.push(s);
			return s;
		};
		return {
			makeSphere: makeSphere,
			makeLightSource: makeLightSource,
			spheres: function(){return spheres;},
			lightSources: function(){return lightSources;}
		};
	})();

	var drawThings=function(){
		svg.drawAxes();
		var i;
		var lineSegments=LineSegmentFactory.lineSegments();
		for(i=0;i<lineSegments.length;i++){
			lineSegments[i].draw();
		}
		var lineLines=LineLineFactory.lineLines();
		for(i=0;i<lineLines.length;i++){
			lineLines[i].draw();
		}
		var planes=PlaneFactory.planes();
		for(i=0;i<planes.length;i++){
			planes[i].draw();
		}
		var spheres=SphereFactory.spheres();
		for(i=0;i<spheres.length;i++){
			spheres[i].draw();
		}
		var lightSources=SphereFactory.lightSources();
		for(i=0;i<lightSources.length;i++){
			lightSources[i].draw();
		}
	};

	var svg=(function(){
		var w,h,whereSvg,where,drawAxes;
		var preventDefault=function(evt){evt.preventDefault();};
		var lineSegments=[];
		var lineLines=[];
		var planes=[];
		var spheres=[];
		var lightSources=[];
		var myMouseEvents=(function(){
			var mouseDown=false;
			return {
				onMove: function(dl, dt){
					if(mouseDown){
						viewPort.rotY(dl/500);
						viewPort.rotX(-dt/500);
						drawThings();
					}
				},
				onDown: function(){mouseDown=true;},
				onUp: function(){mouseDown=false;}
			};
		})();

		var myTouchEvents=(function(){
			var oldTouchLocation=(function(){
				var oldx=0;
				var oldy=0;
				var oneDown=false;
				var twoDown=false;
				var changeOneTo=function(x,y){dx=x-oldx;dy=y-oldy;oldx=x;oldy=y;return {x:dx,y:dy};};
				return {
					onOneStart: function(x,y){changeOneTo(x,y);oneDown=true;},
					onOneMove: function(x,y){
						if(oneDown){
							var d=changeOneTo(x,y);
							viewPort.rotY(d.x/500);
							viewPort.rotX(-d.y/500);
							drawThings();
						}
					},
					onOneEnd: function(){oneDown=false;}
				};
			})();
		})();

		var onMyDoubleTouchStart=function(){
			
		};

		var onMouseDown=function(evt){
			preventDefault(evt);
			myMouseEvents.onDown();
		};
		var onMouseUp=function(){myMouseEvents.onUp();};
		var onMouseMove=function(evt){
			preventDefault(evt);
			var dl=evt.movementX;
			var dt=evt.movementY;
			myMouseEvents.onMove(dl, dt);
		};

		// var onTouchStart=function(evt){
		// 	preventDefault(evt);
		// 	var touches=evt.changedTouches;
		// 	if(touches.length==1){
		// 		var touch=evt.changedTouches[0];
		// 		onMyMouseDown(touch.clientX, touch.clientY);
		// 	}
		// };
		// var onTouchEnd=function(evt){onMyMouseUp();};
		// var onTouchMove=function(evt){
		// 	preventDefault(evt);
		// 	var touches=evt.changedTouches;
		// 	if(touches.length==1){
		// 		var touch=evt.changedTouches[0];
		// 		onMyMouseMove(touch.clientX, touch.clientY);
		// 	}
		// };
		var SvgLine=function(l1,t1,l2,t2,id, color, thickness){
			var svgl={};
			var svgElement=whereSvg.appendChild((function(){
				var NS="http://www.w3.org/2000/svg";
				var line=document.createElementNS(NS, 'line');
				line.setAttribute('x1', l1);
				line.setAttribute('y1', t1);
				line.setAttribute('x2', l2);
				line.setAttribute('y2', t2);
				line.setAttribute('style','stroke: '+color.toString()+'; stroke-width: '+thickness+'; stroke-opacity: 1.5');
				return line;
			})());
			var lt1={left:l1,top:t1};
			var lt2={left:l2,top:t1};
			svgl.setFromTo=function(f,t){lt1=f;lt2=t;};
			svgl.draw=function(){
				svgElement.setAttribute("x1", lt1.left);
				svgElement.setAttribute("y1", lt1.top);
				svgElement.setAttribute("x2", lt2.left);
				svgElement.setAttribute("y2", lt2.top);
			};
			svgl.setColor=function(color1){
				svgElement.setAttribute('style','stroke:'+color1.toString()+';stroke-width: '+thickness+';stroke-opacity: 1.5');
			};
			svgl.makeInfinite=function(hlt){
				var nlt=twoD.makeInfinite(lt1, lt2, hlt);
				lt1=nlt[0];
				lt2=nlt[1];
			};
			svgl.none=function(){svgl.setFromTo({left:0,top:0},{left:0,top:0});};
			return svgl;
		};
		var SvgPlane=function(l1, t1, l2, t2, l3, t3, l4, t4, id, color){
			var svgpl={};
			var svgElement=whereSvg.appendChild((function(){
				var NS="http://www.w3.org/2000/svg";
				var polygon=document.createElementNS(NS, 'polygon');
				polygon.setAttribute('points',l1+','+t1+' '+l2+','+t2+' '+l3+','+t3+' '+l4+','+t4);
				polygon.setAttribute('style','fill: '+color.toString()+'; fill-opacity: 0.4');
				//polygon.setAttribute('id',id);
				return polygon;
			})());
			var lt1={left:l1,top:t1};
			var lt2={left:l2,top:t2};
			var lt3={left:l3,top:t3};
			var lt4={left:l4,top:t4};
			svgpl.setPoints=function(lt1_, lt2_, lt3_, lt4_){
				lt1=lt1_;
				lt2=lt2_;
				lt3=lt3_;
				lt4=lt4_;
			};
			svgpl.full=function(){
				var ltcorners=twoD.ltcorners();
				svgpl.setPoints(ltcorners[0], ltcorners[1], ltcorners[2], ltcorners[3]);
			};
			svgpl.none=function(){
				svgpl.setPoints({left:0,top:0},{left:0,top:0},{left:0,top:0},{left:0,top:0});
			};
			svgpl.setHorizonPoints=function(lt1_, lt2_, inPlaneLt){
				var ltlt=twoD.makeInfinite(lt1_, lt2_, null);
				var otherTwo=twoD.completeTheSquare(ltlt[0], ltlt[1], inPlaneLt);
				svgpl.setPoints(ltlt[0], ltlt[1], otherTwo[0], otherTwo[1]);
			
			};
			svgpl.draw=function(){
				svgElement.setAttribute("points", lt1.left+","+lt1.top+" "+lt2.left+","+lt2.top+" "+lt3.left+","+lt3.top+" "+lt4.left+","+lt4.top);
			};
			svgpl.setColor=function(color1){
				svgElement.setAttribute('style', 'fill: '+color1.toString()+';fill-opacity: 0.4');
			};
			return svgpl;
		};
		var SvgSphere=function(color){
			var svgsph={};
			var svgElement=whereSvg.appendChild((function(){
				var NS="http://www.w3.org/2000/svg";
				var polygon=document.createElementNS(NS, 'polygon');
				polygon.setAttribute('points','0,0 0,0 0,0');
				polygon.setAttribute('style','fill: '+color.toString()+'; fill-opacity: 0.4');
				return polygon;
			})());
			var points=[{left:0,top:0},{left:0,top:0},{left:0,top:0}];
			svgsph.setPoints=function(list){
				points=list;
			};
			svgsph.none=function(){svgsph.setPoints([{left:0,top:0},{left:0,top:0},{left:0,top:0}]);};
			svgsph.draw=function(){
				var s="";
				for(i in points){s+=points[i].left+","+points[i].top+" ";}
				svgElement.setAttribute("points", s);
			};
			svgsph.setColor=function(color1){
				svgElement.setAttribute('style', 'fill: '+color1.toString()+';fill-opacity: 0.4');
			};
			return svgsph;
		};
		var addPlane=function(l1, t1, l2, t2, l3, t3, l4, t4, id, index, color){
			var s=SvgPlane(l1, t1, l2, t2, l3, t3, l4, t4, id, color);
			planes[index]=s;
			return s;
		};
		var addSphere=function(color){
			var s=SvgSphere(color);
			spheres.push(s);
			return s;
		};
		var addLightSource=function(color){
			var s=SvgSphere(color);
			lightSources.push(s);
			return s;
		};
		var addLineSegment=function(l1,t1,l2,t2, id, index, color){
			var s=SvgLine(l1,t1,l2,t2,id,color, 1);
			lineSegments[index]=s;
			return s;
		};
		var addLineLine=function(l1,t1,l2,t2,id,index,color, thickness){
			var s=SvgLine(l1,t1,l2,t2,id,color, thickness);
			lineLines[index]=s;
			return s;
		};
		var svgObject={};
		var init=function(where_){
			where=where_;
			var makeAxisAndLabel=function(axisName){
				var NS="http://www.w3.org/2000/svg";
				var line=document.createElementNS(NS,'line');
				line.setAttribute('x1', 0);
				line.setAttribute('y1', 0);
				line.setAttribute('x2', 0);
				line.setAttribute('y2', 0);
				line.setAttribute('style', 'stroke:rgb(100,100,100);stroke-width:0.5');
				//line.setAttribute('id',axisName+'Axis');
				var text=document.createElementNS(NS,'text');
				text.setAttribute('x', 0);
				text.setAttribute('y', 0);
				text.setAttribute('fill', 'rgb(100,100,100)');
				//text.setAttribute('id', axisName+'AxisLabel');
				text.appendChild(document.createTextNode(axisName));
				return {axis:line,label:text};
			};
			whereSvg=(function(){
				var NS="http://www.w3.org/2000/svg";
				var svgNode=document.createElementNS(NS,"svg");
				//svgNode.ontouchstart=function(event){onTouchStart(event);};
				//svgNode.ontouchmove=function(event){onTouchMove(event);};
				//svgNode.ontouchend=function(event){onTouchEnd(event);};
				svgNode.onmousedown=function(event){onMouseDown(event);};
				svgNode.onmouseup=function(event){onMouseUp(event);};
				svgNode.onmousemove=function(event){onMouseMove(event);};
				svgNode.setAttribute('width','100%');
				svgNode.setAttribute('height','100%');
				svgNode.setAttribute('style', 'border: 1px solid #000000');
				return where.appendChild(svgNode);
			})();

			var axesAndLabels=(function(){
				var svgNode=whereSvg;
				var axesAndLabels=[];

				var al1=makeAxisAndLabel('x');
				axesAndLabels.push({axis:svgNode.appendChild(al1.axis),label:svgNode.appendChild(al1.label)});

				var al2=makeAxisAndLabel('y');
				axesAndLabels.push({axis:svgNode.appendChild(al2.axis),label:svgNode.appendChild(al2.label)});

				var al3=makeAxisAndLabel('z');
				axesAndLabels.push({axis:svgNode.appendChild(al3.axis),label:svgNode.appendChild(al3.label)});

				return axesAndLabels;
			})();

			drawAxes=function(){
				var orlt=viewPort.lt(or);
				var ult=[viewPort.lt(xu), viewPort.lt(yu), viewPort.lt(zu)];
				var nn=["x","y","z"];
				var n, lt, i, axis, label;
				for(i=0;i<3;i++){
					n=nn[i];
					lt=ult[i];
					axis=axesAndLabels[i].axis;
					label=axesAndLabels[i].label;
					axis.setAttribute("x1", orlt.left);
					axis.setAttribute("y1", orlt.top);

					axis.setAttribute("x2", lt.left);
					axis.setAttribute("y2", lt.top);
					
					label.setAttribute("x", lt.left-5);
					label.setAttribute("y", lt.top-5);
				};
			};
			svgObject.drawAxes=drawAxes;
			var currentOnLoad=whereSvg.onload;
			whereSvg.onload=function(){
				if(currentOnLoad){currentOnLoad();}
				(function(){
					console.log("begin adding shapes...");
					var l=0.25;
					PlaneFactory.makePlane(Point(0,-1,0),Point(0,1,0),Color(0,255,0));

					

					SphereFactory.makeSphere(Point(l,l,l), 0.1,Color(255,255,0));

					
					console.log("finish adding shapes");
				})();
				var w_=whereSvg.offsetWidth;
				var h_=whereSvg.offsetHeight;
				svgObject.setWh(w_,h_);
				viewPort.setWh(w_,h_);
				twoD.setWh(w_,h_);
				drawThings();
			};

		};
		svgObject.setWh=function(w_, h_){w=w_,h=h_;};
		svgObject.addLineSegment=addLineSegment;
		svgObject.addLineLine=addLineLine;
		svgObject.addPlane=addPlane;
		svgObject.addSphere=addSphere;
		svgObject.addLightSource=addLightSource;
		svgObject.init=init;
		return svgObject;
	})();

	var sc={
		init: function(where){
			svg.init(where);
			delete sc.init;
		}
	};
	return sc;
};

var scene1=new SvgScene();
scene1.init(document.getElementById("viewPort"));

// var scene2=new SvgScene();
// scene2.init(document.getElementById("viewPort2"));



</script>
</body>
</html>