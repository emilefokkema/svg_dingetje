<html>
<head>
	<title>SVG test</title>
</head>
<body style="overflow: hidden;background-color:rgb(0,0,0)">
<div style="border:1px solid #000000;width:100%;height:100%" id="viewPort">
<a style="-webkit-appearance: button;cursor: hand;padding:5px;position: absolute;right: 10px;top: 110px" onClick="viewPort.scale(1.5);drawThings();">back up</a>
<svg ontouchstart="svg.onTouchStart(event)" ontouchmove="svg.onTouchMove(event)" ontouchend="svg.onTouchEnd(event)" onMouseDown="svg.onMouseDown(event)" onMouseUp="svg.onMouseUp()" onMouseMove="svg.onMouseMove(event)" id="viewPortSvg" width="100%" height="100%" style="border: 1px solid #000000">
<line x1="0" y1="0" x2="200" y2="200" style="stroke:rgb(100,100,100);stroke-width:0.5" id="xAxis"/>
<text x="10" y="10" fill="rgb(100,100,100)" id="xAxisLabel">x</text>
<line x1="0" y1="0" x2="200" y2="200" style="stroke:rgb(100,100,100);stroke-width:0.5" id="yAxis"/>
<text x="10" y="10" fill="rgb(100,100,100)" id="yAxisLabel">y</text>
<line x1="0" y1="0" x2="200" y2="200" style="stroke:rgb(100,100,100);stroke-width:0.5" id="zAxis"/>
<text x="10" y="10" fill="rgb(100,100,100)" id="zAxisLabel">z</text>
</svg>
</div>
<div style="position:absolute;left:20;top:20;background-color:rgb(200,200,200);padding:5px;border:1pt solid rgb(100,100,100);cursor:hand" onClick="show(SceneXml())">hoi!</div>
<div style="position:absolute;left:60;top:60;background-color:rgb(200,200,200);padding:5px;border:1pt solid rgb(100,100,100);width:80%;height:80%;display:none" id="xml_text_alert">
	<table style="width:100%;height:100%">
		<tr><td><textarea id="xml_text" style="resize:none;width:100%;height:100%"></textarea></td></tr>
		<tr><td><a style="-webkit-appearance: button;padding:5px;cursor: hand" onClick="document.getElementById('xml_text_alert').style.display='none'">OK</a></td></tr>
	</table>
</div>
<script language="JavaScript">
var show=function(string){
	document.getElementById("xml_text_alert").style.display="initial";
	document.getElementById("xml_text").value=string;
};
var Color=function(r,g,b){
	this.r=r;
	this.g=g;
	this.b=b;
	this.toString=function(){
		return "rgb("+this.r+", "+this.g+", "+this.b+")";
	};
};

var threeD={
	Point: function(x, y, z){
		this.x=x;
		this.y=y;
		this.z=z;
	},
	Line: function(point1, point2){
		this.p1=point1;
		this.baseVector=point2.minus(point1);
	},
	Rotation: function(around, axis, angle){
		this.around=around;
		this.axis=axis;
		this.angle=angle;
	},
	OtherRotation: function(around, axisDirection, angle){
		this.around=around;
		this.direction=axisDirection;
		this.angle=angle;
	},
	intersectionOfPlanes: function(p1, n1, p2, n2){
		if(n1.sameDirection(n2)||n1.sameDirection(n2.scale(-1))){return null;}
		var base=n1.cross(n2);
		var p1dn1=p1.dot(n1);
		var p2dn2=p2.dot(n2);
		var x,y,z;
		if(base.x!=0){
			x=0;
			y=(n2.z*p1dn1-n1.z*p2dn2)/base.x;
			z=(-n2.y*p1dn1+n1.y*p2dn2)/base.x;
		}
		else if(base.y!=0){
			x=-(n2.z*p1dn1-n1.z*p2dn2)/base.y;
			y=0;
			z=-(-n2.x*p1dn1+n1.x*p2dn2)/base.y;
		}
		else if(base.z!=0){
			x=(n2.y*p1dn1-n1.y*p2dn2)/base.z;
			y=(-n2.x*p1dn1+n1.x*p2dn2)/base.z;
			z=0;
		}
		var basePoint=new threeD.Point(x, y, z);
		return new this.Line(basePoint, basePoint.plus(base));
	},
	makePointFunctions: function(){
		this.Point.prototype.plus=function(p){
			return new threeD.Point(this.x+p.x,this.y+p.y,this.z+p.z);
		};
		this.Point.prototype.scale=function(r){
			return new threeD.Point(this.x*r, this.y*r, this.z*r);
		};
		this.Point.prototype.minus=function(p){
			return this.plus(p.scale(-1));
		};
		this.Point.prototype.dot=function(p){
			return this.x*p.x+this.y*p.y+this.z*p.z;
		};
		this.Point.prototype.cross=function(p){
			return new threeD.Point(this.y*p.z-this.z*p.y,this.z*p.x-this.x*p.z,this.x*p.y-this.y*p.x);
		};
		this.Point.prototype.norm=function(){
			return Math.sqrt(Math.pow(this.x, 2)+Math.pow(this.y, 2)+Math.pow(this.z, 2));
		};
		this.Point.prototype.unit=function(){
			if(this.norm()==0){return this;}
			return this.scale(1/this.norm());
		};
		this.Point.prototype.project=function(p){
			var u=this.unit();
			return u.scale(u.dot(p));
		};
		this.Point.prototype.projectOnPlane=function(point, normal){
			return point.plus(this.minus(point).minus(normal.project(this.minus(point))));
		};
		this.Point.prototype.rotate=function(around, axis, angle){
			var op=this.minus(around);
				if(axis==0){
					var npy=op.y*Math.cos(angle)-op.z*Math.sin(angle);
					var npz=op.z*Math.cos(angle)+op.y*Math.sin(angle);
					return around.plus(new threeD.Point(op.x, npy, npz));
				}
				if(axis==1){
					var npz=op.z*Math.cos(angle)-op.x*Math.sin(angle);
					var npx=op.x*Math.cos(angle)+op.z*Math.sin(angle);
					return around.plus(new threeD.Point(npx, op.y, npz));
				}
				if(axis==2){
					var npx=op.x*Math.cos(angle)-op.y*Math.sin(angle);
					var npy=op.y*Math.cos(angle)+op.x*Math.sin(angle);
					return around.plus(new threeD.Point(npx, npy, op.z));
				}
		};
		this.Point.prototype.rotateWithRotation=function(r){
			return this.rotate(r.around, r.axis, r.angle);
		};
		this.Point.prototype.rotateWithOtherRotation=function(r){
			var op=this.minus(r.around);
			var opUnchanged=r.direction.project(op);
			op=op.minus(opUnchanged);
			if(op.norm()>0){
				var yAxis=r.direction.cross(op);
				op=op.scale(Math.cos(r.angle)).plus(yAxis.unit().scale(op.norm()*Math.sin(r.angle)));
				return r.around.plus(opUnchanged).plus(op);
			}else{
				return new threeD.Point(this.x, this.y, this.z);
			}
		};
		this.Point.prototype.perpendicularTo=function(p){
			return Math.abs(this.dot(p))<0.0005;
		};
		this.Point.prototype.isZero=function(){
			return this.x==0&&this.y==0&&this.z==0;
		};
		this.Point.prototype.sameDirection=function(p){
			return !this.isZero()&&!p.isZero()&&(this.dot(p)==this.norm()*p.norm());
		};
		this.Line.prototype.intersectWithPlane=function(point, normal){
			if(this.baseVector.perpendicularTo(normal)){return null;}
			var t=-normal.dot(this.p1.minus(point))/normal.dot(this.baseVector);
			return this.p1.plus(this.baseVector.scale(t));
		};
		return this;
	},
	makeUnits: function(){
		this.or=new this.Point(0,0,0);
		this.xu=new this.Point(1,0,0);
		this.yu=new this.Point(0,1,0);
		this.zu=new this.Point(0,0,1);
		return this;
	}
}.makePointFunctions().makeUnits();
var twoD={
	w: document.getElementById("viewPortSvg").offsetWidth,
	h: document.getElementById("viewPortSvg").offsetHeight,
	setCorners: function(){
		this.corners=[this.p(0,0), this.p(0,this.h), this.p(this.w, this.h), this.p(this.w,0)];
		this.ltcorners=[{left:0,top:0},{left:0,top:this.h},{left: this.w, top:this.h},{left:this.w,top:0}];
		return this;
	},
	d: function(lt1, lt2){
		return this.plt(lt1).minus(this.plt(lt2)).norm();
	},
	p: function(x,y){
		return new threeD.Point(x,y,0);
	},
	plt: function(lt){
		return this.p(lt.left, lt.top);
	},
	ltp: function(p){
		return {left:p.x,top:p.y};
	},
	intersectLineSegments: function(p1,p2,p3,p4){
		var a=p2.minus(p1);
		var b=p4.minus(p3);
		var c=p3.minus(p1);
		var d=a.cross(b);
		var nd=d.norm();
		if(nd==0){return null;}
		var i=p1.plus(a.scale(c.cross(b).dot(d)/Math.pow(nd, 2)));
		return this.ltp(i);
	},
	distanceToLine: function(p1, direction, p2){
		var l=p2.minus(p1);
		return l.norm()*l.unit().dot(direction.unit());
	},
	distanceToEdge: function(lt1, lt2){
		var direction=this.plt(lt2).minus(this.plt(lt1));
		var d=0;
		for(var i=0;i<4;i++){
			var dd=this.distanceToLine(this.plt(lt2), direction, this.corners[i]);
			if(dd>=d){d=dd;}
		}
		return d;
	},
	moveToEdge: function(lt1, lt2, w, h){
		var d=this.d(lt1, lt2);
		var d1=this.distanceToEdge(lt1, lt2);
		return {left:lt1.left+(lt2.left-lt1.left)*(1+d1/d),top:lt1.top+(lt2.top-lt1.top)*(1+d1/d)};
	},
	makeInfinite: function(lt1, lt2, hlt){
		var d=this.d(lt1, lt2);
		var nlt1=lt1;
		var nlt2=lt2;
		if(d!=0){
			if(hlt!=null&&((hlt.left<lt1.left&&lt1.left<lt2.left)||(hlt.left>lt1.left&&lt1.left>lt2.left))){
				nlt1=hlt;
			}else{
				var toEdge=this.moveToEdge(lt2, lt1, this.w, this.h);
				nlt1=toEdge;
			}
			if(hlt!=null&&((hlt.left<lt2.left&&lt2.left<lt1.left)||(hlt.left>lt2.left&&lt2.left>lt1.left))){
				nlt2=hlt;
			}else{
				var toEdge=this.moveToEdge(lt1, lt2, this.w, this.h);
				nlt2=toEdge;
			}
		}
		return [nlt1, nlt2];
	},
	completeTheSquare: function(lt1, lt2, lt3){
		var step1=this.plt(lt1);
		var step2=this.plt(lt2);
		var a=step2.minus(step1);
		var b=this.plt(lt3).minus(step1);
		if(a.cross(b).z>0){
			var step3=step2.plus(new threeD.Point(-a.y, a.x, 0));
		}else{
			var step3=step2.plus(new threeD.Point(a.y, -a.x, 0));
		}
		var step4=step3.plus(a.scale(-1));
		return [this.ltp(step3),this.ltp(step4)];
	}
}.setCorners();
var viewPort={
	w:0,
	h:0,
	leftTop: new threeD.Point(1, 1, -1),
	leftAxis: new threeD.Point(-1,0,0),
	topAxis: new threeD.Point(0,-1,0),
	viewPoint: new threeD.Point(0,0,-3),
	setSize: function(){
		this.w=document.getElementById("viewPort").offsetWidth;
		this.h=document.getElementById("viewPort").offsetHeight;
		var r=this.h/this.w;
		this.leftTop=new threeD.Point(0.5, 0.5*r,-1);
		this.topAxis=this.topAxis.scale(r);
		this.normal=this.leftAxis.cross(this.topAxis);
		return this;
	},
	setScale: function(r){
		this.leftAxis=this.leftAxis.scale(r);
		this.topAxis=this.topAxis.scale(r);
	},
	horizonLt: function(line){
		var direction=line.baseVector;
		if(direction.perpendicularTo(this.normal)){return null;}
		if(direction.dot(this.normal)<0){direction=direction.scale(-1);}
		return this.lt(this.viewPoint.plus(direction));
	},
	getVisiblePointsOn: function(line){
		if(line.baseVector.perpendicularTo(this.normal)){
			if(line.p1.minus(this.viewPoint).dot(this.normal)>0){return [this.lt(line.p1), this.lt(line.p1.plus(line.baseVector))];}
			else{return [null, null];}
		}
		var p1=line.intersectWithPlane(this.leftTop, this.normal);
		var p2=p1.scale(0.5).plus(line.intersectWithPlane(this.viewPoint, this.normal).scale(0.5));
		return [this.lt(p1),this.lt(p2)];
	},
	getVisiblePointsBetween: function(p1, p2){
		var ltp1=this.lt(p1);
		var ltp2=this.lt(p2);
		if(ltp1==null&&ltp2==null){return [null, null];}
		if(ltp1!=null&&ltp2!=null){return [ltp1, ltp2];}
		var p3=new threeD.Line(p1,p2).intersectWithPlane(this.viewPoint, this.normal);
		if(ltp1==null){
			return [this.lt(p2.plus(p3).scale(0.5)), ltp2];
		}
		if(ltp2==null){
			return [ltp1, this.lt(p1.plus(p3).scale(0.5))];
		}
	},
	lt: function(point){
		var line=new threeD.Line(this.viewPoint, point);
		if(line.baseVector.perpendicularTo(this.normal)){return null;}
		var t=-this.normal.dot(this.viewPoint.minus(this.leftTop))/this.normal.dot(line.baseVector);
		if(t<0){return null;}
		var inPlane=this.viewPoint.plus(line.baseVector.scale(t));
		var leftTopToInPlane=inPlane.minus(this.leftTop);
		var l=this.leftAxis.unit().dot(leftTopToInPlane)/this.leftAxis.norm();
		var t=this.topAxis.unit().dot(leftTopToInPlane)/this.topAxis.norm();
		return {left: l*this.w,top: t*this.h};
	},
	rotateWithOtherRotation: function(r){
		this.leftAxis=this.leftTop.plus(this.leftAxis);
		this.topAxis=this.leftTop.plus(this.topAxis);
		this.leftTop=this.leftTop.rotateWithOtherRotation(r);
		this.leftAxis=this.leftAxis.rotateWithOtherRotation(r).minus(this.leftTop);
		this.topAxis=this.topAxis.rotateWithOtherRotation(r).minus(this.leftTop);
		this.viewPoint=this.viewPoint.rotateWithOtherRotation(r);
		this.normal=this.leftAxis.cross(this.topAxis);
	},
	rotX: function(angle){
		this.rotateWithOtherRotation(new threeD.OtherRotation(new threeD.Point(0,0,0), this.leftAxis, angle));
	},
	rotY: function(angle){
		this.rotateWithOtherRotation(new threeD.OtherRotation(new threeD.Point(0,0,0), this.topAxis, angle));
	},
	rotZ: function(angle){
		this.rotateWithRotation(new threeD.OtherRotation(new threeD.Point(0,0,0), this.leftAxis.cross(this.topAxis), angle));
	},
	scale: function(r){
		this.leftTop=this.leftTop.scale(r);
		this.leftAxis=this.leftAxis.scale(r);
		this.topAxis=this.topAxis.scale(r);
		this.viewPoint=this.viewPoint.scale(r);
		this.normal=this.leftAxis.cross(this.topAxis);
	},
	toString: function(){
		var s='<viewport w="'+this.w+'" h="'+this.h+'">';
		s+='<lefttop x="'+this.leftTop.x+'" y="'+this.leftTop.y+'" z="'+this.leftTop.z+'" />';
		s+='<leftaxis x="'+this.leftAxis.x+'" y="'+this.leftAxis.y+'" z="'+this.leftAxis.z+'" />';
		s+='<topaxis x="'+this.topAxis.x+'" y="'+this.topAxis.y+'" z="'+this.topAxis.z+'" />';
		s+='<viewpoint x="'+this.viewPoint.x+'" y="'+this.viewPoint.y+'" z="'+this.viewPoint.z+'" />';
		s+='</viewport>';
		return s;
	},
}.setSize();
var LineSegmentFactory={
	lineSegments: [],
	currentNumber: 0,
	LineSegment: function(from, to, id, index){
		this.from=from;
		this.to=to;
		this.index=index;
		this.draw=function(){
			var visible=viewPort.getVisiblePointsBetween(this.from, this.to);
			var flt=visible[0];
			var tlt=visible[1];
			if(flt==null||tlt==null){
				this.svg.none();
			}else{
				this.svg.setFromTo(flt, tlt);
				this.svg.draw();
			}
		};
		this.setSvg=function(index){
			this.svg=svg.lineSegments[index];
			return this;
		};
	},
	makeLineSegment: function(from, to, color){
		var id="lineSegment"+this.currentNumber;
		var index=this.currentNumber;
		var flt=viewPort.lt(from);
		var tlt=viewPort.lt(to);
		
		if(flt!=null&&tlt!=null){
			svg.addLineSegment(flt.left, flt.top, tlt.left, tlt.top, id, index, color);
		}else{
			svg.addLineSegment(0,0,0,0, id, index, color);
		}
		this.lineSegments[this.currentNumber]=new this.LineSegment(from, to, id, index).setSvg(this.currentNumber);
		this.currentNumber++;
	}
};
var LineLineFactory={
	lineLines: [],
	currentNumber: 0,
	LineLine: function(p1, p2, id, index){
		this.line=new threeD.Line(p1,p2);
		this.p1=p1;
		this.p2=p2;
		this.index=index;
		this.draw=function(){
			var visible=viewPort.getVisiblePointsOn(this.line);
			var p1lt=viewPort.lt(this.p1);
			if(p1lt==null){p1lt=visible[0];}
			var p2lt=viewPort.lt(this.p2);
			if(p2lt==null){p2lt=visible[1];}
			var hlt=viewPort.horizonLt(this.line);
			if(p1lt==null&&p2lt==null){
				this.svg.none();
			}else{
				this.svg.setFromTo(p1lt, p2lt);
				this.svg.makeInfinite(hlt);
			}
			this.svg.draw();
		};
		this.setSvg=function(index){
			this.svg=svg.lineLines[index];
			return this;
		};
	},
	makeLineLine: function(p1, p2, color, thickness){
		var id="lineLine"+this.currentNumber;
		var index=this.currentNumber;
		var p1lt=viewPort.lt(p1);
		var p2lt=viewPort.lt(p2);
		if(p1lt!=null&&p2lt!=null){
			svg.addLineLine(p1lt.left, p1lt.top, p2lt.left, p2lt.top, id, index, color, thickness);
		}else{
			svg.addLineLine(0,0,0,0, id, index, color, thickness);
		}
		this.lineLines[this.currentNumber]=new this.LineLine(p1,p2,id,index).setSvg(this.currentNumber);
		this.currentNumber++;
	}
};
var PlaneFactory={
	planes: [],
	currentNumber: 0,
	Plane: function(point, normal, id, index, color){
		this.point=point;
		this.normal=normal;
		this.index=index;
		this.color=color;
		if(this.normal.cross(threeD.xu).norm()!=0){
			this.xAxis=this.point.plus(threeD.xu).projectOnPlane(this.point, this.normal).minus(this.point).unit();
		}
		else if(this.normal.cross(threeD.yu).norm()!=0){
			this.xAxis=this.point.plus(threeD.yu).projectOnPlane(this.point, this.normal).minus(this.point).unit();
		}
		else if(this.normal.cross(threeD.zu).norm()!=0){
			this.xAxis=this.point.plus(threeD.zu).projectOnPlane(this.point, this.normal).minus(this.point).unit();
		}
		this.yAxis=this.normal.cross(this.xAxis);
		this.getHorizonLts=function(){
			var horizonDirections=[];
			horizonDirections[0]=this.normal.cross(viewPort.leftAxis);
			horizonDirections[1]=this.normal.cross(horizonDirections[0]);
			horizonDirections[2]=horizonDirections[0].plus(horizonDirections[1]);
			horizonDirections[3]=this.normal.cross(viewPort.topAxis);
			horizonDirections[4]=this.normal.cross(horizonDirections[3]);
			horizonDirections[5]=horizonDirections[3].plus(horizonDirections[4]);
			var nonNullHlt=[];
			var count=0;
			for(var i=0;i<horizonDirections.length;i++){
				var hlt=viewPort.horizonLt(new threeD.Line(this.point, this.point.plus(horizonDirections[i])));
				if(hlt!=null){
					nonNullHlt[count++]=hlt;
				}
				if(count==2){break;}
			}
			return nonNullHlt;
		};
		this.getInPlaneLt=function(){
			var lt;
			var inPlane1=new threeD.Line(viewPort.leftTop, viewPort.leftTop.plus(viewPort.leftAxis)).intersectWithPlane(this.point, this.normal);
			var inPlane2=new threeD.Line(viewPort.leftTop, viewPort.leftTop.plus(viewPort.topAxis)).intersectWithPlane(this.point, this.normal);
			if(inPlane1==null){
				lt=viewPort.lt(inPlane2);
			}else{
				lt=viewPort.lt(inPlane1);
			}
			return lt;
		};
		this.draw=function(){
			if(this.normal.cross(viewPort.normal).norm()==0){
				if(this.point.minus(viewPort.viewPoint).dot(viewPort.normal)>=0){svg.planes[this.index].full();}else{svg.planes[this.index].none();}
				svg.planes[this.index].draw();
				return;
			}
			var nonNullHlt=this.getHorizonLts();
			svg.planes[this.index].setHorizonPoints(nonNullHlt[0], nonNullHlt[1], this.getInPlaneLt());
			svg.planes[this.index].draw();
		};
		this.toString=function(){
			return '<plane reflection="0" diffusion="0.4" color="'+this.color.r+','+this.color.g+','+this.color.b+'">'+
			'<point x="'+this.point.x+'" y="'+this.point.y+'" z="'+this.point.z+'"/>'+
			'<normal x="'+this.normal.x+'" y="'+this.normal.y+'" z="'+this.normal.z+'"/>'+
			'</plane>';
		};
	},
	makePlane: function(point, normal, color){
		var id="plane"+this.currentNumber;
		var index=this.currentNumber;
		for(var i=0;i<this.planes.length;i++){
			var l=threeD.intersectionOfPlanes(point, normal, this.planes[i].point, this.planes[i].normal);
			if(l!=null){LineLineFactory.makeLineLine(l.p1, l.p1.plus(l.baseVector),color, 2);}
		}
		var p=new this.Plane(point, normal, id, index, color);
		var n=20;
		for(var i=-n;i<=n;i++){
			//LineSegmentFactory.makeLineSegment(point.plus(p.xAxis.scale(i)).plus(p.yAxis.scale(n)), point.plus(p.xAxis.scale(i)).plus(p.yAxis.scale(-n)), color);
			//LineSegmentFactory.makeLineSegment(point.plus(p.xAxis.scale(-n)).plus(p.yAxis.scale(i)), point.plus(p.xAxis.scale(n)).plus(p.yAxis.scale(i)), color);
			LineLineFactory.makeLineLine(point.plus(p.xAxis.scale(i)).plus(p.yAxis.scale(n)), point.plus(p.xAxis.scale(i)).plus(p.yAxis.scale(-n)), color, 1);
			LineLineFactory.makeLineLine(point.plus(p.xAxis.scale(-n)).plus(p.yAxis.scale(i)), point.plus(p.xAxis.scale(n)).plus(p.yAxis.scale(i)), color, 1);
		}
		this.planes[this.currentNumber]=p;
		svg.addPlane(0,0,0,0,0,0,0,0,id,index, color);
		this.currentNumber++;
	}
};
var SphereFactory={
	spheres: [],
	currentNumber: 0,
	Sphere: function(center, radius, id, index){
		this.center=center;
		this.radius=radius;
		this.index=index;
		this.draw=function(){
			var toCenter=this.center.minus(viewPort.viewPoint);
			var d=toCenter.norm();
			var r=this.radius;
			if(d<=r){this.svg.none();this.svg.draw();return;}
			var startingPoint=this.center.plus(toCenter.cross(viewPort.leftAxis).unit().scale(d*r/Math.sqrt(d*d-r*r)));
			var pointList=[startingPoint];
			var n=24;
			var rot=new threeD.OtherRotation(viewPort.viewPoint, toCenter, 2*Math.PI/n);
			for(var i=1;i<n;i++){
				startingPoint=startingPoint.rotateWithOtherRotation(rot);
				pointList[pointList.length]=startingPoint;
			}
			var ltList=[];
			for(var i=0;i<pointList.length;i++){
				var lt=viewPort.lt(pointList[i]);
				if(lt!=null){ltList[ltList.length]=lt;}
			}
			this.svg.setPoints(ltList);
			this.svg.draw();
		};
		this.pointWithCoords=function(lo, la){
			return this.center.plus(threeD.xu.rotate(threeD.or, 2, la).rotate(threeD.or, 1, lo).scale(this.radius));
		};
		this.pointsOnMeridian=function(lo, n){
			var pointsOnMeridian=[];
			for(var la=-Math.PI/2; la<=Math.PI/2; la+=Math.PI/n){
				pointsOnMeridian[pointsOnMeridian.length]=this.pointWithCoords(lo,la);
			}
			return pointsOnMeridian;
		};
		this.pointsOnLatitude=function(la, n){
			var pointsOnLatitude=[];
			for(var lo=-Math.PI;lo<=Math.PI;lo+=2*Math.PI/n){
				pointsOnLatitude[pointsOnLatitude.length]=this.pointWithCoords(lo,la);
			}
			return pointsOnLatitude;
		};
		this.setSvg=function(index){
			this.svg=svg.spheres[index];
			return this;
		};
		this.makeGrid=function(color){
			for(var lo=-Math.PI;lo<=Math.PI;lo+=Math.PI/5){
				var pointsOnMeridian=this.pointsOnMeridian(lo,20);
				for(var i=1;i<pointsOnMeridian.length;i++){
					LineSegmentFactory.makeLineSegment(pointsOnMeridian[i-1], pointsOnMeridian[i], color);
				}
			}
			for(var la=-Math.PI/2;la<=Math.PI/2;la+=Math.PI/5){
				var pointsOnLatitude=this.pointsOnLatitude(la, 20);
				for(var i=1;i<pointsOnLatitude.length;i++){
					LineSegmentFactory.makeLineSegment(pointsOnLatitude[i-1], pointsOnLatitude[i], color);
				}
			}
		};
	},
	makeSphere: function(center, radius, color){
		var id="sphere"+this.currentNumber;
		var index=this.currentNumber;
		svg.addSphere(id, index, color);
		var s=new this.Sphere(center, radius, id, index).setSvg(this.currentNumber);
		this.spheres[this.currentNumber]=s;
		s.makeGrid(color);
		this.currentNumber++;
	}
};
var LightSourceFactory={
	lightSources: [],
	currentNumber: 0,
	LightSource: function(center, radius, id, index, color){
		this.color=color;
		SphereFactory.Sphere.call(this, center, radius, index);
		this.setSvg=function(index){
			this.svg=svg.lightSources[index];
			return this;
		};
		this.toString=function(){
			var s='<lightsource color="'+this.color.r+','+this.color.g+','+this.color.b+'" radius="'+this.radius+'">'+
			'<location x="'+this.center.x+'" y="'+this.center.y+'" z="'+this.center.z+'" />'+
			'</lightsource>';
			return s;
		};
	},
	makeLightSource: function(center, radius, color){
		var id="lightSource"+this.currentNumber;
		var index=this.currentNumber;
		svg.addLightSource(id, index, color);
		var s=new this.LightSource(center, radius, id, index,color).setSvg(this.currentNumber);
		this.lightSources[this.currentNumber]=s;
		s.makeGrid(color);
		this.currentNumber++;
	}
};
var drawAxes=function(){
	var orlt=viewPort.lt(threeD.or);
	var xult=viewPort.lt(threeD.xu);
	var yult=viewPort.lt(threeD.yu);
	var zult=viewPort.lt(threeD.zu);

	document.getElementById("xAxis").setAttribute("x1", orlt.left);
	document.getElementById("xAxis").setAttribute("y1", orlt.top);

	document.getElementById("xAxis").setAttribute("x2", xult.left);
	document.getElementById("xAxis").setAttribute("y2", xult.top);
	
	document.getElementById("xAxisLabel").setAttribute("x", xult.left-5);
	document.getElementById("xAxisLabel").setAttribute("y", xult.top-5);

	document.getElementById("yAxis").setAttribute("x1", orlt.left);
	document.getElementById("yAxis").setAttribute("y1", orlt.top);

	document.getElementById("yAxis").setAttribute("x2", yult.left);
	document.getElementById("yAxis").setAttribute("y2", yult.top);
	
	document.getElementById("yAxisLabel").setAttribute("x", yult.left-5);
	document.getElementById("yAxisLabel").setAttribute("y", yult.top-5);

	document.getElementById("zAxis").setAttribute("x1", orlt.left);
	document.getElementById("zAxis").setAttribute("y1", orlt.top);

	document.getElementById("zAxis").setAttribute("x2", zult.left);
	document.getElementById("zAxis").setAttribute("y2", zult.top);
	
	document.getElementById("zAxisLabel").setAttribute("x", zult.left-5);
	document.getElementById("zAxisLabel").setAttribute("y", zult.top-5);
};
var drawThings=function(){
	drawAxes();
	
	var lineSegments=LineSegmentFactory.lineSegments;
	for(var i=0;i<lineSegments.length;i++){
		lineSegments[i].draw();
	}
	var lineLines=LineLineFactory.lineLines;
	for(var i=0;i<lineLines.length;i++){
		lineLines[i].draw();
	}
	var planes=PlaneFactory.planes;
	for(var i=0;i<planes.length;i++){
		planes[i].draw();
	}
	var spheres=SphereFactory.spheres;
	for(var i=0;i<spheres.length;i++){
		spheres[i].draw();
	}
	var lightSources=LightSourceFactory.lightSources;
	for(var i=0;i<lightSources.length;i++){
		lightSources[i].draw();
	}
};
var SceneXml=function(){
	var s='<?xml version="1.0" encoding="UTF-8"?><scene xmlns="http://www.sogyo.nl/efokkema_raytrace" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ><group>';
	var planes=PlaneFactory.planes;
	for(var i=0;i<planes.length;i++){
		s+=planes[i].toString();
	}
	var lightSources=LightSourceFactory.lightSources;
	for(var i=0;i<lightSources.length;i++){
		s+=lightSources[i].toString();
	}
	return s+'</group>'+viewPort.toString()+'</scene>';
};
var SvgSphere=function(id, color){
	document.getElementById("viewPortSvg").innerHTML+="<polygon points='0,0 0,0 0,0' style='fill: "+color.toString()+";fill-opacity: 0.4' id='"+id+"'>";
	this.points=[{left:0,top:0},{left:0,top:0},{left:0,top:0}];
	this.setPoints=function(list){
		this.points=list;
	};
	this.none=function(){this.setPoints([{left:0,top:0},{left:0,top:0},{left:0,top:0}]);}
	this.draw=function(){
		var s="";
		for(i in this.points){s+=this.points[i].left+","+this.points[i].top+" ";}
		document.getElementById(id).setAttribute("points", s);
	};
};
var SvgLine=function(l1,t1,l2,t2,id, color, thickness){
	document.getElementById("viewPortSvg").innerHTML+="<line x1='"+l1+"' y1='"+t1+"' x2='"+l2+"' y2='"+t2+"' style='stroke:"+color.toString()+";stroke-width: "+thickness+";stroke-opacity: 1.5' id='"+id+"'>";
	this.lt1={left:l1,top:t1};
	this.lt2={left:l2,top:t2};
	this.setFromTo=function(f,t){this.lt1=f;this.lt2=t;};
	this.draw=function(){
		document.getElementById(id).setAttribute("x1", this.lt1.left);
		document.getElementById(id).setAttribute("y1", this.lt1.top);
		document.getElementById(id).setAttribute("x2", this.lt2.left);
		document.getElementById(id).setAttribute("y2", this.lt2.top);
	};
	this.makeInfinite=function(hlt){
		var nlt=twoD.makeInfinite(this.lt1, this.lt2,hlt);
		this.lt1=nlt[0];
		this.lt2=nlt[1];
		
	};
	this.none=function(){this.setFromTo({left:0,top:0},{left:0,top:0});}
};
var SvgPlane=function(l1, t1, l2, t2, l3, t3, l4, t4, id, color){
	document.getElementById("viewPortSvg").innerHTML+="<polygon points='"+l1+","+t1+" "+l2+","+t2+" "+l3+","+t3+" "+l4+","+t4+"' style='fill: "+color.toString()+";fill-opacity: 0.4' id='"+id+"'>";
	this.lt1={left:l1,top:t1};
	this.lt2={left:l2,top:t2};
	this.lt3={left:l3,top:t3};
	this.lt4={left:l4,top:t4};
	this.setPoints=function(lt1, lt2, lt3, lt4){
		this.lt1=lt1;
		this.lt2=lt2;
		this.lt3=lt3;
		this.lt4=lt4;
	};
	this.full=function(){
		this.setPoints(twoD.ltcorners[0], twoD.ltcorners[1], twoD.ltcorners[2], twoD.ltcorners[3]);
	};
	this.none=function(){this.setPoints({left:0,top:0},{left:0,top:0},{left:0,top:0},{left:0,top:0});};
	
	this.setHorizonPoints=function(lt1, lt2, inPlaneLt){
		var ltlt=twoD.makeInfinite(lt1, lt2, null);
		var otherTwo=twoD.completeTheSquare(ltlt[0], ltlt[1], inPlaneLt);
		this.setPoints(ltlt[0], ltlt[1], otherTwo[0], otherTwo[1]);
		
	};
	this.draw=function(){
		var t=function(x){return x};
		document.getElementById(id).setAttribute("points", t(this.lt1.left)+","+t(this.lt1.top)+" "+t(this.lt2.left)+","+t(this.lt2.top)+" "+t(this.lt3.left)+","+t(this.lt3.top)+" "+t(this.lt4.left)+","+t(this.lt4.top));
	};
};
var svg={
	preventDefault: function(evt){
		evt.preventDefault();
	},
	mouseLocation: {oldl:0,oldt:0,setOldLt: function(l,t){this.oldl=l;this.oldt=t;}},
	lineSegments: [],
	lineLines: [],
	planes: [],
	spheres: [],
	lightSources: [],
	mouseDown: false,
	onMyMouseMove: function(l,t){
		if(this.mouseDown){
			var dl=l-this.mouseLocation.oldl;
			var dt=t-this.mouseLocation.oldt;
			viewPort.rotY(dl/1000);
			viewPort.rotX(-dt/1000);
			drawThings();
			this.mouseLocation.setOldLt(l, t);
		}
	},
	onMyMouseDown: function(l, t){
		this.mouseLocation.setOldLt(l, t);this.mouseDown=true;
	},
	onMyMouseUp: function(){this.mouseDown=false;},
	onMouseDown: function(evt){
		this.preventDefault(evt);
		var l=evt.clientX;
		var t=evt.clientY;
		this.onMyMouseDown(l,t);
	},
	onMouseUp: function(){this.onMyMouseUp();},
	onMouseMove: function(evt){
		this.preventDefault(evt);
		var l=evt.clientX;
		var t=evt.clientY;
		this.onMyMouseMove(l,t);
	},
	onTouchStart: function(evt){
		this.preventDefault(evt);
		var touches=evt.changedTouches;
		if(touches.length==1){
			var touch=evt.changedTouches[0];
			this.onMyMouseDown(touch.clientX, touch.clientY);
		}
	},
	onTouchEnd: function(evt){
		this.onMyMouseUp();
	},
	onTouchMove: function(evt){
		this.preventDefault(evt);
		var touches=evt.changedTouches;
		if(touches.length==1){
			var touch=evt.changedTouches[0];
			this.onMyMouseMove(touch.clientX, touch.clientY);
		}
	},
	addLineSegment: function(l1,t1,l2,t2, id, index, color){
		this.lineSegments[index]=new SvgLine(l1,t1,l2,t2,id,color, 1);
	},
	addLineLine: function(l1,t1,l2,t2,id,index,color, thickness){
		this.lineLines[index]=new SvgLine(l1,t1,l2,t2,id,color, thickness);
	},
	addPlane: function(l1, t1, l2, t2, l3, t3, l4, t4, id, index, color){
		this.planes[index]=new SvgPlane(l1, t1, l2, t2, l3, t3, l4, t4, id, color);
	},
	addSphere: function(id, index, color){
		this.spheres[index]=new SvgSphere(id, color);
	},
	addLightSource: function(id, index, color){
		this.lightSources[index]=new SvgSphere(id, color);
	},
	setR: function(){
		this.r=Math.sqrt(Math.pow(this.w, 2)+Math.pow(this.h, 2));
		return this;
	}
};

var p1=new threeD.Point(0.5,0.5,0.5);
var p2=new threeD.Point(-0.5,0.5,0.5);
var p3=new threeD.Point(0.5,-0.5,0.5);
var p4=new threeD.Point(-0.5,-0.5,0.5);
var p5=new threeD.Point(0.5,0.5,-0.5);
var p6=new threeD.Point(-0.5,0.5,-0.5);
var p7=new threeD.Point(0.5,-0.5,-0.5);
var p8=new threeD.Point(-0.5,-0.5,-0.5);

PlaneFactory.makePlane(new threeD.Point(0,-1,0), new threeD.Point(0,1,0), new Color(80,20,20));
//SphereFactory.makeSphere(new threeD.Point(0,0,1), 0.1, new Color(20,80,20));
//SphereFactory.makeSphere(new threeD.Point(1,0,1), 0.1, new Color(20,80,20));
//SphereFactory.makeSphere(threeD.or, 0.3,new Color(20,80,20));
LightSourceFactory.makeLightSource(new threeD.Point(0,3,0), 2,new Color(255,255,255));
//PlaneFactory.makePlane(new threeD.Point(5,0,0), new threeD.Point(-1,0,0), new Color(100,0,0));
//PlaneFactory.makePlane(new threeD.Point(0,0,5), new threeD.Point(0,0,-1), new Color(0,100,0));









drawThings();




</script>
</body>
</html>